

== Principles

Software entropy of the system increases over a period of time unless it is refactored


http://www.laputan.org/mud/

=== Clean code

keeping your code clean is not just cost effective; it’s a matter of
*professional survival*.

[verse, Ron Jeffries, on clean code] 
Reduced duplication, high expressiveness, 
and early building of simple abstractions.
That’s what makes clean code for me.

== good practices
=== Method, Variable, Function, Interface, trait naming 
1. Use intention-revealing names
2. Avoid disinformation
3. Make meaningful distinctions
4. Use pronounceable names
5. Pick one word per concept
6. Add meaningful context
7. Classes and objects should have noun or noun phrase names
8. Methods should have verb or verb phrase names


=== Functions
1. keep it small (2-3 lines)
2. Do one thing
3. One level of abstraction per function
4. Apply the stepdown rule consistently
5. Avoid passing boolean arguments, rather seperate function into two
6. Keep arguments to one, two at most for functions
7. Prefer Exceptions to Returning Error Codes

`In the case of a monadic function, the function and argument should form a very nice verb/noun pair.`



=== Microservices

Microservices vs Monoliths
http://blog.arungupta.me/microservices-monoliths-noops/

Design patterns
http://blog.arungupta.me/microservice-design-patterns/

=== Guidelines on testing code 

One particularly good method to start using thrid party APIs in your code base is to use them in *Learning Tests*. 
These are normal tests which essentially start interacting with the api, but in ways you would expect. This allows you
to quickly find out the lmitations in how it might solve some of your problems.

== the three laws of TDD
---

. *First law* You may not write production code until you have written a failing unit test.
. *Second law* You may not write more of a unit test than is sufficient to fail, and not compiling
is failing.
. *Third law* You may not write more production code than is sufficient to pass the currently
failing test.

> These three laws lock you into a cycle that is perhaps thirty seconds long. The tests
and the production code are written together, with the tests just a few seconds ahead of the
production code.

The usual approach to writing Unit tests is to *BUILD-OPERATE-TEST* with `One assert per test`

[quote, Kent Beck, a design is “simple” if it follows these rules]
• Runs all the tests
• Contains no duplication
• Expresses the intent of the programmer
• Minimizes the number of classes and methods
 

=== class organization
. Classes should be small

[Blockquote]
.class should begin with a list of variables. Public static constants, if any, should come first. Then private static variables, followed by private
instance variables. There is seldom a good reason to have a public variable.

.Public functions should follow the list of variables. We like to put the private utilities
called by a public function right after the public function itself. This follows the stepdown
rule and helps the program read like a newspaper article.

== Systems design 

. Separation of concerns (AOP concept)
. Dependency Injection (inversion of control)


